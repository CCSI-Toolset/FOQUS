/* *************************************/
/* Regression interpolator from PSUADE.*/
/* ====================================*/
/* This file contains information for interpolation
   using response surface. Follow the steps below:
   1. move this file to *.c file (e.g. main.c)
   2. Compile main.c (cc -o main main.c -lm) 
   3. run: main input output
          where input has the number of inputs and
          the input values
*/
/* ====================================*/
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
int interpolate(int,double*,double*,double*);
main(int argc, char **argv) {
  int    i, iOne=1, nInps;
  double X[5], Y, S;
  FILE   *fIn=NULL, *fOut=NULL;
  if (argc != 3) {
    printf("ERROR: not enough argument.\n");
    exit(1);
  }
  fIn = fopen(argv[1], "r");
  if (fIn == NULL) {
    printf("ERROR: cannot open input file.\n");
    exit(1);
  }
  fscanf(fIn, "%d", &nInps);
  if (nInps != 5) {
    printf("ERROR - wrong nInputs.\n");
    exit(1);
  }
  for (i=0; i<5; i++) fscanf(fIn, "%lg", &X[i]);
  fclose(fIn);
  interpolate(iOne, X, &Y, &S);
  printf("Y = %e\n", Y);
  printf("S = %e\n", S);
  fOut = fopen(argv[2], "w");
  if (fOut == NULL) {
     printf("ERROR: cannot open output file.\n");
     exit(1);
  }
  fprintf(fOut," %e\n", Y);
  fclose(fOut);
}

/* *************************************/
/*  Regression interpolation function  */
/* X[0], X[1],   .. X[m-1]   - first point
 * X[m], X[m+1], .. X[2*m-1] - second point
 * ... */
/* ==============================================*/
static double
regCoefs[6] = 
{
   8.4213366134975234e+05,
  -7.2010334185907177e+03,
  -2.8371705003996340e+04,
  -3.9838615319647644e+04,
  -4.8309753160079745e+04,
  -1.1863671925411936e+04,
};
static double invCovMat[6][6] = 
{
 {   4.9080360292016220e+08,  -5.9604644775390625e-08,  -8.1956386566162109e-08,   0.0000000000000000e+00,  -2.0861625671386719e-07,  -1.9744038581848145e-07 },
 {  -6.7055225372314453e-08,   5.0218726006321126e+08,   2.9802322387695312e-08,   0.0000000000000000e+00,   1.4901161193847656e-08,   0.0000000000000000e+00 },
 {  -1.0430812835693359e-07,  -2.9802322387695312e-08,   5.2319442464530140e+08,   0.0000000000000000e+00,   5.9604644775390625e-08,   1.4901161193847656e-08 },
 {   0.0000000000000000e+00,   0.0000000000000000e+00,   0.0000000000000000e+00,   5.2637501581335485e+08,   0.0000000000000000e+00,   0.0000000000000000e+00 },
 {  -1.8626451492309570e-07,   2.9802322387695312e-08,   5.9604644775390625e-08,   0.0000000000000000e+00,   5.4560469172877252e+08,   1.4901161193847656e-08 },
 {  -1.8626451492309570e-07,  -2.2351741790771484e-08,  -1.4901161193847656e-08,   0.0000000000000000e+00,  -1.4901161193847656e-08,   5.8582131920861745e+08 },
};
static int N=6;
/* ====================================*/
int interpolate(int npts,double *X,double *Y,double *S){
  int    ii, jj, kk, nInps=5;
  double y, *x, *x2, std, dtmp;
  x2 = (double *) malloc(6 * sizeof(double));
  for (ii = 0; ii < npts; ii++) {
    x = &X[ii * 5];
    y = regCoefs[0];
    x2[0] = 1.0;
    x2[1] = (x[0] - -3.795593e-04) / 5.779225e+00;
    x2[2] = (x[1] - 1.541606e-04) / 5.779364e+00;
    x2[3] = (x[2] - 1.702648e-04) / 5.779224e+00;
    x2[4] = (x[3] - 8.304650e-05) / 5.779754e+00;
    x2[5] = (x[4] - 5.939995e-04) / 5.779825e+00;
    y += regCoefs[1] * x2[1];
    y += regCoefs[2] * x2[2];
    y += regCoefs[3] * x2[3];
    y += regCoefs[4] * x2[4];
    y += regCoefs[5] * x2[5];
    Y[ii] = y * 1.000000e+00 + 0.000000e+00;
    std = 0.0;
    for (jj = 0; jj < N; jj++) {
      dtmp = 0.0;
      for (kk = 0; kk < N; kk++)
        dtmp += invCovMat[jj][kk] * x2[kk];
      std += dtmp * x2[jj];
    }
    std = sqrt(std);
    S[ii] = std;
  }
  free(x2);
  return 0;
}

/* ==============================================*/
